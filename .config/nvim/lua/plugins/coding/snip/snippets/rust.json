{
    "cpdmoj": {
        "prefix": "cpdmoj",
        "body": [
            "// https://oj.vnoi.info/problem/$1",
            "",
            "#[macro_use]",
            "extern crate dmoj;",
            "",
            "fn main() {",
            "    // number of test",
            "    let nt = scan!(usize);",
            "    // read test",
            "    for _ in 0..nt {",
            "        let (m, n) = scan!(usize, usize);",
            "        println!(\"{} {}\", m, n);",
            "    }",
            "}"
        ],
        "description": "Competitive Programming Template for DMOJ"
    },
    "cpcf": {
        "prefix": "cpcf",
        "body": [
            "// https://codeforces.com/contest/$1/problem/$2",
            "",
            "#[allow(unused_imports)]",
            "use std::cmp::{max, min};",
            "#[allow(unused_imports)]",
            "use std::io::{stdin, stdout, BufWriter, Write};",
            "",
            "#[derive(Default)]",
            "struct Scanner {",
            "    buffer: Vec<String>,",
            "}",
            "impl Scanner {",
            "    #[allow(dead_code)]",
            "    fn next<T: std::str::FromStr>(&mut self) -> T {",
            "        loop {",
            "            if let Some(token) = self.buffer.pop() {",
            "                return token.parse().ok().expect(\"Failed parse\");",
            "            }",
            "            let mut input = String::new();",
            "            stdin().read_line(&mut input).expect(\"Failed read\");",
            "            self.buffer = input.split_whitespace().rev().map(String::from).collect();",
            "        }",
            "    }",
            "    #[allow(dead_code)]",
            "    fn next_vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {",
            "        (0..n).map(|_| self.next::<T>()).collect()",
            "    }",
            "    #[allow(dead_code)]",
            "    fn next_chars(&mut self) -> Vec<char> {",
            "        self.next::<String>().chars().collect()",
            "    }",
            "    #[allow(dead_code)]",
            "    fn next_line(&mut self) -> String {",
            "        let mut input = String::new();",
            "        stdin().read_line(&mut input).expect(\"Failed read\");",
            "        input",
            "    }",
            "}",
            "",
            "fn main() {",
            "    let mut scan = Scanner::default();",
            "    let out = &mut BufWriter::new(stdout());",
            "",
            "    let nt = scan.next::<usize>();",
            "    for _ in 0..nt {",
            "        let n = scan.next::<usize>();",
            "        writeln!(out, \"{}\", n).ok();",
            "    }",
            "}"
        ],
        "description": "Competitive Programming Template for codeforces contest"
    },
    "cpcfo": {
        "prefix": "cpcfo",
        "body": [
            "// https://codeforces.com/contest/$1/problem/$2",
            "",
            "#[allow(unused_imports)]",
            "use std::io::{self, BufRead};",
            "use std::vec::Vec;",
            "",
            "fn main() {",
            "    let stdin = io::stdin();",
            "    let mut lines = stdin.lock().lines();",
            "    let nt: i32 = lines.next().unwrap().unwrap().trim().parse().unwrap();",
            "    ",
            "    for _ in 0..nt {",
            "        let nm: Vec<usize> = lines.next().unwrap().unwrap()",
            "            .split_whitespace()",
            "            .map(|s| s.parse().unwrap())",
            "            .collect();",
            "        let (n, m) = (nm[0], nm[1]);",
            "        println!(\"{} {}\", m, n);",
            "    }",
            "}"
        ],
        "description": "Competitive Programming Template for codeforces contest"
    }
}
