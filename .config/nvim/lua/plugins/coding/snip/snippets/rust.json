{
    "cpdmoj": {
        "prefix": "cpdmoj",
        "body": [
            "// https://oj.vnoi.info/problem/$1",
            "",
            "#[macro_use]",
            "extern crate dmoj;",
            "",
            "fn main() {",
            "    // number of test",
            "    let nt = scan!(usize);",
            "    // read test",
            "    for _ in 0..nt {",
            "        let (m, n) = scan!(usize, usize);",
            "        $0",
            "        println!(\"{} {}\", m, n);",
            "    }",
            "}"
        ],
        "description": "Competitive Programming Template for DMOJ"
    },
    "cpcf": {
        "prefix": "cpcf",
        "body": [
            "// https://codeforces.com/contest/$1/problem/$2",
            "",
            "#[allow(unused_imports)]",
            "use std::cmp::{max, min};",
            "#[allow(unused_imports)]",
            "use std::io::{stdin, stdout, BufWriter, Write};",
            "",
            "#[derive(Default)]",
            "struct Scanner {",
            "    buffer: Vec<String>,",
            "}",
            "impl Scanner {",
            "    #[allow(dead_code)]",
            "    fn next<T: std::str::FromStr>(&mut self) -> T {",
            "        loop {",
            "            if let Some(token) = self.buffer.pop() {",
            "                return token.parse().ok().expect(\"Failed parse\");",
            "            }",
            "            let mut input = String::new();",
            "            stdin().read_line(&mut input).expect(\"Failed read\");",
            "            self.buffer = input.split_whitespace().rev().map(String::from).collect();",
            "        }",
            "    }",
            "    #[allow(dead_code)]",
            "    fn next_vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {",
            "        (0..n).map(|_| self.next::<T>()).collect()",
            "    }",
            "    #[allow(dead_code)]",
            "    fn next_chars(&mut self) -> Vec<char> {",
            "        self.next::<String>().chars().collect()",
            "    }",
            "    #[allow(dead_code)]",
            "    fn next_line(&mut self) -> String {",
            "        let mut input = String::new();",
            "        stdin().read_line(&mut input).expect(\"Failed read\");",
            "        input",
            "    }",
            "}",
            "",
            "fn main() {",
            "    let mut scan = Scanner::default();",
            "    let out = &mut BufWriter::new(stdout());",
            "",
            "    let nt = scan.next::<usize>();",
            "    for _ in 0..nt {",
            "        let n = scan.next::<usize>();",
            "        $0",
            "        writeln!(out, \"{}\", n).ok();",
            "    }",
            "}"
        ],
        "description": "Competitive Programming Template for codeforces contest"
    },
    "cpcfo": {
        "prefix": "cpcfo",
        "body": [
            "// https://codeforces.com/contest/$1/problem/$2",
            "",
            "#[allow(unused_imports)]",
            "use std::io::{self, BufRead};",
            "use std::vec::Vec;",
            "",
            "fn main() {",
            "    let stdin = io::stdin();",
            "    let mut lines = stdin.lock().lines();",
            "    let nt: i32 = lines.next().unwrap().unwrap().trim().parse().unwrap();",
            "    ",
            "    for _ in 0..nt {",
            "        let nm: Vec<usize> = lines.next().unwrap().unwrap()",
            "            .split_whitespace()",
            "            .map(|s| s.parse().unwrap())",
            "            .collect();",
            "        let (n, m) = (nm[0], nm[1]);",
            "        println!(\"{} {}\", m, n);",
            "    }",
            "}"
        ],
        "description": "Competitive Programming Template for codeforces contest"
    },
    "wriyn": {
        "prefix": "wriyn",
        "body": [
            "writeln!(out, \"{}\", if ${1:ans} { \"YES\" } else { \"NO\" }).ok();"
        ]
    },
    "wrivec": {
        "prefix": "wrivec",
        "body": [
            "${1:a}.iter().for_each(|x| {",
            "    write!(out, \"{} \", x).ok();",
            "});",
            "writeln!(out).ok();"
        ]
    },
    "cpat": {
        "prefix": "cpat",
        "body": [
            "// https://atcoder.jp/contests/$1/tasks/$1_$2",
            "",
            "#[allow(unused_imports)]",
            "use proconio::input;",
            "#[allow(unused_imports)]",
            "use std::cmp::{max, min};",
            "",
            "fn solve() {",
            "    input! {",
            "        n: usize",
            "    };",
            "    $0",
            "    println!(\"{}\", n);",
            "}",
            "",
            "fn main() {",
            "    // input! {tc: usize};",
            "    let tc = 1;",
            "    for _ in 0..tc {",
            "        solve();",
            "    }",
            "}"
        ],
        "description": "Competitive Programming Template for codeforces contest"
    }
}
